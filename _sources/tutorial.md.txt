# Tutorial

This package provides classes to represent genomic experiments, commonly generated by sequencing experiments. It provides similar interfaces and functionality as the [Bioconductor equivalent](https://github.com/Bioconductor/SummarizedExperiment).

A `SummarizedExperiment` contains three slots,

- `row_data`: Feature information e.g. genes, transcripts, exons, etc.
- `column_data`: Sample information about the columns of the matrices.
- `assays`: A dictionary of matrices with assay names as keys, e.g. counts, logcounts etc.

The package currently provides both `SummarizedExperiment` & `RangedSummarizedExperiment` representations. A key difference between these two is the rows of a `RangedSummarizedExperiment` object is a [GenomicRanges](https://github.com/BiocPy/GenomicRanges), representing genomic regions of interest.

## Construct a `SummarizedExperiment` object

First, lets create random experimental "count" data along with feature and sample information.

```python
from random import random
import pandas as pd
import numpy as np
from biocframe import BiocFrame

nrows = 200
ncols = 6
counts = np.random.rand(nrows, ncols)
row_data = BiocFrame(
    {
        "seqnames": [
            "chr1",
            "chr2",
            "chr2",
            "chr2",
            "chr1",
            "chr1",
            "chr3",
            "chr3",
            "chr3",
            "chr3",
        ]
        * 20,
        "starts": range(100, 300),
        "ends": range(110, 310),
        "strand": ["-", "+", "+", "*", "*", "+", "+", "+", "-", "-"] * 20,
        "score": range(0, 200),
        "GC": [random() for _ in range(10)] * 20,
    }
)

col_data = pd.DataFrame(
    {
        "treatment": ["ChIP", "Input"] * 3,
    }
)
```

### `SummarizedExperiment`

A `SummarizedExperiment` is a base class to represent any genomic experiment. This class expects features (`row_data`) to be either a pandas `DataFrame` or any variant of `BiocFrame`.

```python
se = SummarizedExperiment(
    assays={"counts": counts}, row_data=row_data, column_data=col_data
)
```

### `RangedSummarizedExperiment`

`RangedSummarizedExperiment` requires features to be a [`GenomicRanges`](https://github.com/BiocPy/GenomicRanges) object.

```python
# convert our pandas dataframe to genomic ranges.
from genomicranges import GenomicRanges
gr = GenomicRanges.from_pandas(row_data.to_pandas())

trse = RangedSummarizedExperiment(
    assays={"counts": counts}, row_data=row_data, row_ranges=gr, column_data=col_data
)
```

## Accessors

Properties can be accessed directly from the class instance.

```python
tse.assays
tse.row_data or # tse.row_ranges
tse.column_data
tse.metadata

# Access the counts assay
tse.assay("counts")
```

## Subset an experiment

You can subset a `SummarizedExperiment` object using the `[]` slice operator.

### Slice by index position

```python
# subset the first 10 rows and the first 3 samples
subset_tse = tse[0:10, 0:3]
```

### Slice by row names or column names

Alternatively, we can use a sequence of row (feature) or column (sample) names to subset a `SummarizedExperiment` . To demonstrate this, we create a `SummarizedExperiment` object with index names.

```python
row_data = BiocFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [100, 200, 300],
        "end": [110, 210, 310]
    }
)
col_data = BiocFrame(
    {
        "sample": ["SAM_1", "SAM_3", "SAM_3"],
        "disease": ["True", "True", "True"],
    },
    index=["cell_1", "cell_2", "cell_3"],
)
se_with_index_names = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    row_data=row_data,
    column_data=col_data,
    row_names=["HER2", "BRCA1", "TPFK"],
    column_names=["cell_1", "cell_2", "cell_3"]
)

# subset by name
subset = se_with_index_names[
    ["HER2", "BRCA1"], ["cell_1", "cell_3"]
]
```

In the case a name does not exist, an error will be thrown:

```python
# throws error because "RAND" does not exist
subset_se_with_index_names = se_with_index_names[
    ["HER2", "BRCA1", "RAND"], ["cell_1", "cell_3"]
]
```

### Slice by a boolean vector

Similarly you could also slice by a boolean array. **_Note, the boolean vectors should contain the same number of features for the row slice and the same number of samples for the column slice._**

```python
# subset with boolean array
subset_se_with_bools = se_with_index_names[
    [True, True, False], [True, False, True]
]
```

## Range based operations

`RangedSummarizedExperiment` objects on the other hand supports many interval based operations similar to `GenomicRanges`.

```python
query = pd.DataFrame({"seqnames": ["chr2",], "starts": [4], "ends": [6], "strand": ["+"]})

query = GenomicRanges.from_pandas(query)

tse.subset_by_overlaps(query)
```

Checkout the [API docs](./api/modules.rst) or `GenomicRanges`` for list of interval based operations.

## Combine operations

The combine methods in `SummarizedExperiment` are used to merge or combine multiple `SummarizedExperiment` objects, allowing users to aggregate data from different experiments or conditions. First, let's create multiple `SummarizedExperiment` objects for combining later.

```python
rowData1 = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [10293804, 12098948, 20984392],
        "end": [28937947, 3872839, 329837492]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData1 = pd.DataFrame(
    {
        "sample": ["SAM_1", "SAM_3", "SAM_3"],
        "disease": ["True", "True", "True"],
    },
    index=["cell_1", "cell_2", "cell_3"],
)
se1 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    row_data=rowData1,
    column_data=colData1,
    metadata={"seq_type": "paired"},
)

rowData2 = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [10293804, 12098948, 20984392],
        "end": [28937947, 3872839, 329837492]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData2 = pd.DataFrame(
    {
        "sample": ["SAM_4", "SAM_5", "SAM_6"],
        "disease": ["True", "False", "True"],
    },
    index=["cell_4", "cell_5", "cell_6"],
)
se2 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    row_data=rowData2,
    column_data=colData2,
    metadata={"seq_platform": "Illumina NovaSeq 6000"},
)

rowData3 = pd.DataFrame(
    {
        "seqnames": ["chr_7", "chr_1", "chr_Y"],
        "start": [1084390, 1874937, 243879798],
        "end": [243895239, 358908298, 390820395]
    },
    index=["MYC", "BRCA2", "TPFK"],
)
colData3 = pd.DataFrame(
    {
        "sample": ["SAM_7", "SAM_8", "SAM_9"],
        "disease": ["True", "False", "False"],
        "doublet_score": [.15, .62, .18]
    },
    index=["cell_7", "cell_8", "cell_9"],
)
se3 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3)),
        "beta": np.random.beta(a=1, b=1, size=(3, 3))
    },
    row_data=rowData3,
    column_data=colData3,
    metadata={"seq_platform": "Illumina NovaSeq 6000"},
)
```

```python
from biocutils import relaxed_combine_columns, combine_columns
se_combined = combine_columns(se2, se1)

se_relaxed_combine = relaxed_combine_columns(se1, se2, se3)
```

Similarly one can perform `combine_rows` and `relaxed_combine_rows` operations.
