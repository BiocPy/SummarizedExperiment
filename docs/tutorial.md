# Tutorial

This package provides classes to represent genomic experiments, commonly generated by sequencing experiments. It provides similar interfaces and functionality as the [Bioconductor equivalent](https://github.com/Bioconductor/SummarizedExperiment).

A `SummarizedExperiment` contains three slots,

- `row_data`: Feature information e.g. genes, transcripts, exons, etc.
- `col_data`: Sample information about the columns of the matrices.
- `assays`: A dictionary of matrices with assay names as keys, e.g. counts, logcounts etc.

The package currently provides both `SummarizedExperiment` & `RangedSummarizedExperiment` representations. A key difference between these two is the rows of a `RangedSummarizedExperiment` object is a [GenomicRanges](https://github.com/BiocPy/GenomicRanges), representing genomic regions of interest.

## Construct a `SummarizedExperiment` object

First, lets create random experimental "count" data along with feature and sample information.

```python
nrows = 200
ncols = 6
counts = np.random.rand(nrows, ncols)

df_gr = pd.DataFrame(
    {
        "seqnames": [
            "chr1",
            "chr2",
            "chr2",
            "chr2",
            "chr1",
            "chr1",
            "chr3",
            "chr3",
            "chr3",
            "chr3",
        ]
        * 20,
        "starts": range(100, 300),
        "ends": range(110, 310),
        "strand": ["-", "+", "+", "*", "*", "+", "+", "+", "-", "-"] * 20,
        "score": range(0, 200),
        "GC": [random() for _ in range(10)] * 20,
    }
)

col_data = pd.DataFrame(
    {
        "treatment": ["ChIP", "Input"] * 3,
    }
)
```

### `SummarizedExperiment`

A `SummarizedExperiment` is a base class to represent any genomic experiment. This class expects features (`row_data`) to be either a pandas `DataFrame` or any variant of `BiocFrame`.

```python
se = SummarizedExperiment(
    assays={"counts": counts}, row_data=df_gr, col_data=col_data
)
```

### `RangedSummarizedExperiment`

`RangedSummarizedExperiment` requires features to be a [`GenomicRanges`](https://github.com/BiocPy/GenomicRanges) object.

```python
# convert our pandas dataframe to genomic ranges.
gr = genomicranges.from_pandas(df_gr)

rse = SummarizedExperiment(
    assays={"counts": counts}, row_ranges=gr, col_data=col_data
)
```

### File backed mode for large datasets

Alternatively, SE and RSE supports any matrix that implements the shape property (`shape`) and the slice operation (`__getitem__`).
For large datasets that won't fit into memory, lazy representations provided by [FileBackedArray](https://github.com/BiocPy/FileBackedArray) can be used as assays. **_Note: This package currently only supports h5 based formats._**

```python
from filebackedarray import H5BackedSparseData

df_gr = pd.DataFrame(
    {
        "seqnames": [
            "chr1",
            "chr2",
            "chr2",
            "chr2",
            "chr1",
            "chr1",
            "chr3",
            "chr3",
            "chr3",
            "chr3",
        ]
        * 100,
        "starts": range(0, 1000),
        "ends": range(0, 1000),
        "strand": ["-", "+", "+", "*", "*", "+", "+", "+", "-", "-"] * 100,
        "score": range(0, 1000),
        "GC": [random() for _ in range(10)] * 100,
    }
)

col_data = pd.DataFrame({"treatment": ["ChIP"] * 3005,})

assay = H5BackedSparseData("tests/data/tenx.sub.h5", "matrix")

tse = SummarizedExperiment(
    assays={"counts_backed": assay},
    row_data=df_gr,
    col_data=col_data,
)
```

## Accessors

Properties can be accessed directly from the class instance.

```python
tse.assays
tse.row_data or # tse.row_ranges
tse.col_data
tse.metadata

# Access the counts assay
tse.assay("counts")
```

## Subset an experiment

You can subset a `SummarizedExperiment` object using the `[]` slice operator.

### slice by index position

```python
# subset the first 10 rows and the first 3 samples
subset_tse = tse[0:10, 0:3]
```

### slice by row names or column names

Alternatively, we can use a sequence of row (feature) or column (sample) names to subset a `SummarizedExperiment` . To demonstrate this, we create a `SummarizedExperiment` object with index names.

```python
rowData_with_index_names = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [100, 200, 300],
        "end": [110, 210, 310]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData_with_index_names = pd.DataFrame(
    {
        "sample": ["SAM_1", "SAM_3", "SAM_3"],
        "disease": ["True", "True", "True"],
    },
    index=["cell_1", "cell_2", "cell_3"],
)
se_with_index_names = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    row_data=rowData_with_index_names,
    col_data=colData_with_index_names
)

# subset by name
subset_se_with_index_names = se_with_index_names[
    ["HER2", "BRCA1"], ["cell_1", "cell_3"]
]
```

In the case a name does not exist, an error will be thrown:

```python
# throws error because "RAND" does not exist
subset_se_with_index_names = se_with_index_names[
    ["HER2", "BRCA1", "RAND"], ["cell_1", "cell_3"]
]
```

### slice by a boolean vector

Similarly you could also slice by a boolean array. **_Note, the boolean vectors should contain the same number of features for the row slice and the same number of samples for the column slice._**

```python
# subset with boolean array
subset_se_with_bools = se_with_index_names[
    [True, True, False], [True, False, True]
]
```

## Range based operations

`RangedSummarizedExperiment` objects on the other hand supports many interval based operations similar to `GenomicRanges`.

```python
query = {"seqnames": ["chr2",], "starts": [4], "ends": [6], "strand": ["+"]}

query = GenomicRanges(query)

tse.subset_by_overlaps(query)
```

Checkout the [API docs](./api/modules.rst) or `GenomicRanges`` for list of interval based operations.

## Combine operations

The combine methods in `SummarizedExperiment` are used to merge or combine multiple `SummarizedExperiment` objects, allowing users to aggregate data from different experiments or conditions. First, let's create multiple `SummarizedExperiment` objects for combining later.

```python
rowData1 = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [10293804, 12098948, 20984392],
        "end": [28937947, 3872839, 329837492]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData1 = pd.DataFrame(
    {
        "sample": ["SAM_1", "SAM_3", "SAM_3"],
        "disease": ["True", "True", "True"],
    },
    index=["cell_1", "cell_2", "cell_3"],
)
se1 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    row_data=rowData1,
    col_data=colData1,
    metadata={"seq_type": "paired"},
)

rowData2 = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [10293804, 12098948, 20984392],
        "end": [28937947, 3872839, 329837492]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData2 = pd.DataFrame(
    {
        "sample": ["SAM_4", "SAM_5", "SAM_6"],
        "disease": ["True", "False", "True"],
        "doublet_score": [.05, .23, .54]
    },
    index=["cell_4", "cell_5", "cell_6"],
)
se2 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    row_data=rowData2,
    col_data=colData2,
    metadata={"seq_platform": "Illumina NovaSeq 6000"},
)

rowData3 = pd.DataFrame(
    {
        "seqnames": ["chr_7", "chr_1", "chr_Y"],
        "start": [1084390, 1874937, 243879798],
        "end": [243895239, 358908298, 390820395]
    },
    index=["MYC", "BRCA2", "TPFK"],
)
colData3 = pd.DataFrame(
    {
        "sample": ["SAM_7", "SAM_8", "SAM_9"],
        "disease": ["True", "False", "False"],
        "doublet_score": [.15, .62, .18]
    },
    index=["cell_7", "cell_8", "cell_9"],
)
se3 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3)),
        "beta": np.random.beta(a=1, b=1, size=(3, 3))
    },
    row_data=rowData3,
    col_data=colData3,
    metadata={"seq_platform": "Illumina NovaSeq 6000"},
)
```

### Combine Experiments by column

Concatenate columns (samples or cells) of multiple `SummarizedExperiment` objects, returning a `SummarizedExperiment` with columns equal to the concatenation of columns across all inputs. `combineCols()` allows for differences in the number and names of rows, differences in the available `col_data` fields, and even differences in the available `assays` among the objects being combined.

```python
se_combined = se1.combine_cols(se2, se3) # OR se1.combineCols([se2, se3])
```

Parameters are available to keep duplicate rows, or perform row-wise concatenation instead of index available on the rows.

**_Note: currently does not support range based concatenation._**
