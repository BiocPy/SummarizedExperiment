# Tutorial

This package provides classes to represent genomic experiments, commonly generated by sequencing experiments. This package tried to provide the same interfaces and functionality as the [Bioconductor equivalent](https://github.com/Bioconductor/SummarizedExperiment).

A `SummarizedExperiment` contains three slots,

- `rowData`: feature information e.g. genes, transcripts, exons, etc.
- `colData`: sample information about the columns of the matrices.
- `Assays`: a dictionary of matrices with keys specifying the assay name. 


The package currently provides both `SummarizedExperiment` & `RangeSummarizedExperiment` representations, a fundamental difference between these two is the rows of a `RangedSummarizedExperiment` object represent [GenomicRanges](https://github.com/BiocPy/GenomicRanges) of interest.

## Construct a `SummarizedExperiment` object

First, lets create some example matrices along with their feature and sample information.

```python
nrows = 200
ncols = 6
counts = np.random.rand(nrows, ncols)

df_gr = pd.DataFrame(
    {
        "seqnames": [
            "chr1",
            "chr2",
            "chr2",
            "chr2",
            "chr1",
            "chr1",
            "chr3",
            "chr3",
            "chr3",
            "chr3",
        ]
        * 20,
        "starts": range(100, 300),
        "ends": range(110, 310),
        "strand": ["-", "+", "+", "*", "*", "+", "+", "+", "-", "-"] * 20,
        "score": range(0, 200),
        "GC": [random() for _ in range(10)] * 20,
    }
)

colData = pd.DataFrame(
    {
        "treatment": ["ChIP", "Input"] * 3,
    }
)
```

Finally, create an appropriate summarized experiment class. 

### `SummarizedExperiment`

A `SummarizedExperiment` is a base class to represent any genomic experiment. This class expects features (`rowData`) to be either a pandas `DataFrame` or any variant of `BiocFrame`.

```python
se = SummarizedExperiment(
    assays={"counts": counts}, rowData=df_gr, colData=colData
)
```

###  `RangeSummarizedExperiment`

`RangeSummarizedExperiment` requires features to be a [`GenomicRanges`](https://github.com/BiocPy/GenomicRanges) object.

```python
# convert our pandas dataframe to genomic ranges.
gr = GenomicRanges.fromPandas(df_gr)

rse = SummarizedExperiment(
    assays={"counts": counts}, rowRanges=gr, colData=colData
)
```

### File backed mode for large datasets

In addition to fully realized matrices in memory, SE/RSE also supports file backed arrays and matrices. [FileBackedArray](https://github.com/BiocPy/FileBackedArray) package provides lazy representation for matrices stored in hdf5 files.

```python
from filebackedarray import H5BackedSparseData

df_gr = pd.DataFrame(
    {
        "seqnames": [
            "chr1",
            "chr2",
            "chr2",
            "chr2",
            "chr1",
            "chr1",
            "chr3",
            "chr3",
            "chr3",
            "chr3",
        ]
        * 100,
        "starts": range(0, 1000),
        "ends": range(0, 1000),
        "strand": ["-", "+", "+", "*", "*", "+", "+", "+", "-", "-"] * 100,
        "score": range(0, 1000),
        "GC": [random() for _ in range(10)] * 100,
    }
)

colData = pd.DataFrame({"treatment": ["ChIP"] * 3005,})

assay = H5BackedSparseData("tests/data/tenx.sub.h5", "matrix")

tse = SummarizedExperiment(
    assays={"counts_backed": assay},
    rowData=df_gr,
    colData=colData,
)
```


## Accessors

Many properties can be accessed directly from the class instance.

```python
tse.assays
tse.rowData or # tse.rowRanges
tse.colData
tse.metadata

# Access the counts assay
tse.assay("counts")
```

## Subset an experiment

You can subset a `SummarizedExperiment` object using the `[]` slice operator.

### slice by index position

```python
# subset the first 10 rows and the first 3 samples
subset_tse = tse[0:10, 0:3]
```
### slice by row names or column names
Alternatively, we can use a sequence of row (feature) or column (sample) names to subset a `SummarizedExperiment` . To demonstrate this, we create a `SummarizedExperiment` object with index names.

```python
rowData_with_index_names = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [100, 200, 300],
        "end": [110, 210, 310]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData_with_index_names = pd.DataFrame(
    {
        "sample": ["SAM_1", "SAM_3", "SAM_3"],
        "disease": ["True", "True", "True"],
    },
    index=["cell_1", "cell_2", "cell_3"],
)
se_with_index_names = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    rowData=rowData_with_index_names,
    colData=colData_with_index_names
)

# subset by name
subset_se_with_index_names = se_with_index_names[
    ["HER2", "BRCA1"], ["cell_1", "cell_3"]
]
```

In the case a name does not exist, an error will be thrown:

```python
# throws error because "RAND" does not exist
subset_se_with_index_names = se_with_index_names[
    ["HER2", "BRCA1", "RAND"], ["cell_1", "cell_3"]
]
```

### slice by a boolean vector

similarly you could also slice by a boolean array. Note, the boolean vectors should contain the same number of features for the row slice and the same number of samples for the column slice.

```python
# subset with boolean array
subset_se_with_bools = se_with_index_names[
    [True, True, False], [True, False, True]
]
```

## Range based operations

`RangeSummarizedExperiment` objects on the other hand supports many interval based operations similar to `GenomicRanges`.


```python
query = {"seqnames": ["chr2",], "starts": [4], "ends": [6], "strand": ["+"]}

query = GenomicRanges(query)

tse.subsetByOverlaps(query)
```

Checkout the API docs or GenomicRanges for list of interval based operations.

## Combine operations

The combine methods in `SummarizedExperiment` are used to merge or combine multiple `SummarizedExperiment` objects, allowing users to aggregate data from different experiments or conditions. First, let's create multiple `SummarizedExperiment` objects for combining later.

```python
rowData1 = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [10293804, 12098948, 20984392],
        "end": [28937947, 3872839, 329837492]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData1 = pd.DataFrame(
    {
        "sample": ["SAM_1", "SAM_3", "SAM_3"],
        "disease": ["True", "True", "True"],
    },
    index=["cell_1", "cell_2", "cell_3"],
)
se1 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    rowData=rowData1,
    colData=colData1,
    metadata={"seq_type": "paired"},
)

rowData2 = pd.DataFrame(
    {
        "seqnames": ["chr_5", "chr_3", "chr_2"],
        "start": [10293804, 12098948, 20984392],
        "end": [28937947, 3872839, 329837492]
    },
    index=["HER2", "BRCA1", "TPFK"],
)
colData2 = pd.DataFrame(
    {
        "sample": ["SAM_4", "SAM_5", "SAM_6"],
        "disease": ["True", "False", "True"],
        "doublet_score": [.05, .23, .54]
    },
    index=["cell_4", "cell_5", "cell_6"],
)
se2 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3))
    },
    rowData=rowData2,
    colData=colData2,
    metadata={"seq_platform": "Illumina NovaSeq 6000"},
)

rowData3 = pd.DataFrame(
    {
        "seqnames": ["chr_7", "chr_1", "chr_Y"],
        "start": [1084390, 1874937, 243879798],
        "end": [243895239, 358908298, 390820395]
    },
    index=["MYC", "BRCA2", "TPFK"],
)
colData3 = pd.DataFrame(
    {
        "sample": ["SAM_7", "SAM_8", "SAM_9"],
        "disease": ["True", "False", "False"],
        "doublet_score": [.15, .62, .18]
    },
    index=["cell_7", "cell_8", "cell_9"],
)
se3 = SummarizedExperiment(
    assays={
        "counts": np.random.poisson(lam=5, size=(3, 3)),
        "lognorm": np.random.lognormal(size=(3, 3)),
        "beta": np.random.beta(a=1, b=1, size=(3, 3))
    },
    rowData=rowData3,
    colData=colData3,
    metadata={"seq_platform": "Illumina NovaSeq 6000"},
)
```

### combineCols()

concatenate columns (samples or cells) of multiple `SummarizedExperiment` objects, returning a `SummarizedExperiment` with columns equal to the concatenation of columns across all inputs. `combineCols()` allows for differences in the number and names of rows, differences in the available `colData` fields, and even differences in the available `assays` among the objects being combined. 

```python
se_combined = se1.combineCols(se2, se3) # OR se1.combineCols([se2, se3])
```

parameters are available to keep duplicate rows, or perform row-wise concatenation instead of index available on the rows.

***Note: currently does not support range based concatenation.***
